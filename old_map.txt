#pragma region REMOVE WHEN PARSING IMPLEMENTED // !

#include <time.h>
char	**generate_map(int *w, int *h)
{
	#if 1
	const int HEIGHT = 6;
	const int WIDTH = 25;
	const char *fixed_map[] = {
		"111111111111111111111111",
		"100000000011000000000001",
		"101100000001000000110001",
		"100100000000000000010001",
		"101100000111000000000001",
		"111111111111111111111111",
	};
	#else
	const int HEIGHT = 24;
	const int WIDTH = 25;
	const char *fixed_map[] = {
		"1111111141155<;=55555555",
		"100000000015000005000005",
		"101100000155000009000005",
		"1002000000D000000:000005",
		"101100000155000009000005",
		"10000000001500000555D555",
		"10000000001567855>>>0>>>",
		"1111D131111>?B?>>>00000>",
		">>>>0>>>>>>?00000>00000>",
		">0000000000A00000E00000>",
		">0000000000@00000>00000>",
		">0000000000>@>>>@>>>>D>>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">0000000000000000000000>",
		">>>>>>>>>>>>>>>>>>>>>>>>"
	};
	#endif
	char **tiles;
	int y;

	tiles = malloc(sizeof(char *) * (HEIGHT + 1));
	if (!tiles)
		return NULL;

	for (y = 0; y < HEIGHT; y++)
	{
		tiles[y] = strdup(fixed_map[y]);
		if (!tiles[y])
		{
			while (--y >= 0)
				free(tiles[y]);
			free(tiles);
			return NULL;
		}
	}
	tiles[HEIGHT] = NULL;

	*w = WIDTH;
	*h = HEIGHT;
	return tiles;
}

static void	load_textures(t_game *g)
{
	static char *g_texture_files[] = {
		"textures/gray_brick_wall_south.xpm",
		"textures/gray_brick_wall_south_shadowed.xpm",
		"textures/gray_brick_wall_east.xpm",
		"textures/gray_brick_wall_east_shadowed.xpm",
		"textures/hitler_picture.xpm",
		"textures/hitler_picture_shadowed.xpm",
		"textures/nazi_eagle_picture.xpm",
		"textures/nazi_eagle_picture_shadowed.xpm",

		"textures/ceiling_angles6.xpm",
		"textures/floor_chessed.xpm",

		"textures/office_beige_wall_flag_nazi.xpm",
		"textures/office_beige_wall_portrait_hitler.xpm",
		"textures/office_beige_wall_flag_nazi_military.xpm",
		"textures/office_beige_wall_plain.xpm",
		"textures/office_beige_archway.xpm",
		"textures/office_beige_wall_lamp.xpm",
		"textures/office_beige_window_large_curtain.xpm",
		"textures/office_beige_wall_portrait_lenin.xpm",
		"textures/office_beige_wall_portrait_stalin.xpm",

		"textures/lab_metal_grey_tiles.xpm",
		"textures/lab_metal_grey_tiles_blood1.xpm",
		"textures/lab_metal_grey_tiles_blood2.xpm",
		"textures/lab_metal_grey_tiles_blood3.xpm",
		"textures/lab_metal_grey_tiles_blood4.xpm",
		"textures/lab_metal_grey_tiles_clock.xpm",
		"textures/lab_metal_sign_radiation.xpm",
		"textures/lab_metal_light_on.xpm",


		"textures/office_beige_wall_flag_britain.xpm",
		"textures/office_beige_wall_flag_france.xpm",
		"textures/office_beige_wall_flag_japan.xpm",
		"textures/office_beige_wall_flag_soviet.xpm",
		"textures/office_beige_wall_map.xpm"
	};

	size_t	i;
	i = 0;
	g->textures = ft_calloc(TEXTR_NUMBER, sizeof (t_image *));
	while (i < TEXTR_NUMBER)
	{
		g->textures[i] = im_load_from_xpmfile(g->mlx, g_texture_files[i]);
		if (!g->textures[i])
		{
			printf("The texture %s was not loaded\n", g_texture_files[i]);
			while (--i)
				im_cleanup(g->mlx, g->textures[i]);
			game_cleanup(g);
			exit(1);
		}
		++i;
	}
}